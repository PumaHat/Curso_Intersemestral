<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xml:lang="es" xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Introducción a Linux</title>
    <link rel="stylesheet" href="assets/reset.css" />
    <link rel="stylesheet" href="assets/reveal.css" />
    <link rel="stylesheet" href="assets/theme/dracula.css" />
    <link rel="stylesheet" href="assets/highlight/monokai.css" />
    <link rel="stylesheet" href="assets/fonts.css" />
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section>
          <section>
            <div style="display: flex; height: 250px; justify-content: center">
              <img src="images/Tux.svg" style="margin-right: 2-em;"/>
              <svg version="1.1" viewBox="0 0 560 652" xmlns="http://www.w3.org/2000/svg" style="margin-left: 2em;"><style type="text/css">.st2{fill:#67b32e}.st3{fill:#fff}</style><path class="st2" d="m104 299 47 72h52l20 17 9 63-5-67 13 5-73-62h-37z"/><path class="st2" d="m454 301-45 70-53-1-20 18-8 63 4-66-12 4 72-63 37 1z"/><path class="st3" d="M35 334c5 3 11 4 16 1l10-7 112-87s7-7 10 0c2 3 2 8 1 11a37 37 0 0 0 1 19c3 8 3 14 3 14s-87 47-157 130l3 18 3 35 86 74S-5 458 0 443l26-70c2-6 3-12 3-19-1-6 1-12 5-18z"/><path class="st3" d="m523 334c-4 3-10 4-15 1l-10-7-112-87s-7-7-10 0c-2 3-2 8-1 11a37 37 0 0 1-1 19c-3 8-3 14-3 14s87 48 157 130l-4 18-2 35-86 74s128-84 123-98l-26-71c-2-6-3-12-3-19 1-6-1-12-5-18a91 91 0 0 1-2-2z"/><path class="st3" d="m46 223s44 32 83-33c0 0 15-34 16-43l1-60s7-8 19-13c13-5 29-12 34-7 5 4 8 10 5 17s-15 74-12 92c3 14 1 33 0 43-1 3-3 7-6 9-20 14-102 69-141 104-1 2-4 1-6 0-4-5-9-13-4-24 8-15 8-29 6-33-2-5-16-22 5-52z"/><path class="st3" d="m281 209h-1c-23 0-45 4-67 12-12 5-23 11-23 17l-1 24s2 14 6 19c0 0 49-16 63-17h22"/><path class="st3" d="m512 223s-44 32-83-33c0 0-16-34-17-43l-1-60s-6-8-19-13-29-12-34-7c-5 4-7 10-4 17s15 74 11 92c-3 14-1 33 1 43 0 3 2 7 5 9 21 14 102 69 141 104 2 2 5 1 6 0 4-5 9-13 4-24-7-15-7-29-6-33 2-5 16-22-4-52z"/><path class="st3" d="m275 41c10 0 20 1 30 5 9 3 22 7 28 7s13 4 17 7c3 2 3 5 2 7-4 5-8 12-5 18a262 262 0 0 1 13 83v51c1 2-1 3-3 2-10-6-40-21-81-18h5c-40-3-70 12-80 18-2 1-4 0-4-2v-51a262 262 0 0 1 13-83c3-6-1-13-4-18-2-2-1-5 1-7 4-3 11-7 18-7 5 0 18-4 28-7 9-4 19-6 29-6v1"/><path class="st3" d="m276 209h2c22 0 45 4 66 12 13 5 23 11 24 17l1 24s-2 14-7 19c0 0-48-16-62-17h-20"/><path class="st3" d="m219 500 15 24 23 9 1 22 20 16v-49z"/><path class="st3" d="m283 522-1 49 21-16v-22l23-10 15-23z"/><path class="st3" d="m185 474-8 21 5 26 15 19-18-16-6-28z"/><path class="st3" d="m375 475 8 21-5 26-15 18 18-16 6-28z"/><path class="st3" d="m83 422 10 38 29 35z"/><path class="st3" d="m478 421-10 38-28 36z"/><path class="st3" d="M142 92v-7l-38-11-24-24L41 0v152l15 42-8 23 4 3 6-26-9-42 30 35 10 2-29-40-8-80 50 96 8 10L43 6l35 49 37 48-8-25z"/><path class="st3" d="m418 92v-6l37-12 25-24 39-50-1 152-14 42 8 24-4 2-6-26 8-42-29 35-10 2 28-40 8-80-49 96-8 10 67-169-35 49-37 49 8-26z"/><path class="st3" d="m227 644 9-9 44 8 41-7 10 9-52 7z"/><path class="st3" d="m87 362-2 2 16 28z"/><path class="st3" d="m471 366 2 2-16 27z"/><path class="st3" d="m280 260c-2-4-2 20-2 38l1 34c1 1 3 2 2-35 0-13 1-38-1-37z"/><path class="st3" d="m328 541 95 14 3 3-3 2-95-15c-2 0-3-1-3-2 0-2 2-2 3-2z"/><path class="st3" d="m318 555 101 46c1 0 2 2 1 3l-3 1-101-46-2-3z"/><path class="st3" d="m314 574 84 48 1 3-3 1-84-48-1-3z"/><path class="st3" d="m229 542-95 14c-2 0-3 2-3 3l3 2 96-15 2-2c0-2-1-2-3-2z"/><path class="st3" d="m239 556-100 46c-2 0-3 2-2 3l4 1 100-46c2 0 3-2 2-3z"/><path class="st3" d="m243 575-83 48c-2 1-2 3-2 3l4 1 83-49c2 0 2-2 2-2z"/><g transform="translate(-28 -57)"><path class="st3" d="m404 648-10-4-8 8 10 6z"/><path class="st3" d="m407 645 3-4-9-4-4 3z"/><path class="st3" d="m381 658 10 6 2-3-9-6z"/><path class="st3" d="m477 556-1-10-7 17-39 42 9 1 26-30-5 20 85-78v-33l5-9-13-15-16 45z"/><path class="st3" d="m429 618-10-2-15 18 9 4z"/><path class="st3" d="m358 702 30-35-10-6-29 32z"/><path class="st3" d="m208 645 10-4-4-4-9 5z"/><path class="st3" d="m202 638 9-4-15-17-10 2z"/><path class="st3" d="m219 658 9-5-7-9-10 5z"/><path class="st3" d="m189 609-10 2 3 4 10-2z"/><path class="st3" d="m265 692-29-31-10 6 29 34z"/><path class="st3" d="m145 561-8-16v9l-45-49-15-45-14 14 5 10 1 32 84 79-4-20 27 32 9-2z"/></g></svg>
            </div>
            <h1><span style="font-size: 5rem">Introducción a Linux</span></h1>
            <p>PumaHat Cybersecurity Team</p>
          </section>
          <section>
            <h2>Instructores</h2>
            <ul>
              <li>Alicia Aislinn González Nava</li>
              <li>Ricardo Organista Álvarez</li>
            </ul>
          </section>
          <section>
            <h2>Horario de clase</h2>
            <dl>
              <dt>Inicia</dt><dd>29 de julio de 2024</dd>
              <dt>Termina</dt><dd>2 de agosto de 2024</dd>
              <dt>Horario</dt><dd></dd>
            </dl>
          </section>
          <section>
            <h2>Objetivos</h2>
            <p>El alumno adquirirá los conocimientos necesarios para desenvolverse en un entorno linux incluyendo la gestión de archivos y procesos, la utilización de comandos básicos, y la automatización de tareas mediante scripts de shell.</p>
          </section>
          <section>
            <h2>Temario</h2>
            <ol>
              <li><a href="#primertema">Generalidades del sistema Unix</a></li>
              <li><a href="#segundotema">Sistemas de archivos</a></li>
              <li><a href="#tercertema">Sistemas de paquetes</a></li>
              <li><a href="#cuartotema">Comandos de terminal</a></li>
              <li><a href="#quintotema">Terminal</a></li>
              <li><a href="#sextotema">Bash</a></li>
            </ol>
          </section>
        </section>
        <!--PRIMER TEMA-->
        <section>
          <section id="primertema">
            <h2>Tema 1:<br />Generalidades del sistema Unix</h2>
          </section>
          <section>
            <h2>¿Por qué esto es importante?</h2>
            <ul style="font-size: smaller;">
              <li>Es más fácil trabajar en un sistema que conoces
                <ul>
                  <li>¿Qué recursos provee el sistema?</li>
                  <li>¿Cómo puedo adaptarlo a mis necesidades?</li>
                  <li>¿Cómo preparo mi entorno de pruebas?</li>
                </ul>
              </li>
              <li>Es más fácil vulnerar un sistema que conoces
                <ul>
                  <li>¿Qué sistemas está ejecutando? ¿Cuáles son los más vulnerables?</li>
                  <li>¿Hay alguna vulnerabilidad sin corregir? ¿Cómo puedo explotarla?</li>
                </ul>
              </li>
            </ul>
          </section>
          <section>
            <h2>Nomenclatura</h2>
            <p>Existe una controversia en cuanto a cómo nombrar a un sistema operativo que utilice el kernel Linux y el software del proyecto de GNU.</p>
          </section>
          <section>
            <h2>Nomenclatura:<br /> GNU/Linux</h2>
            <ul>
              <li>Linux es realmente el nombre de un kernel.</li>
              <li>La mayoría de los sistemas operativos para escritorio que utilizan el kernel Linux utilizan software del proyecto GNU para funcionar (<i>glibc</i>, <i>coreutils</i>).</li>
              <li>Existen sistemas operativos que, sin embargo, no utilizan software del proyecto GNU:
                <ul><li>Android es el ejemplo más popular.</li></ul>
              </li>
            </ul>
          </section>
          <section>
            <h2>Nomenclatura: Linux</h2>
            <ul>
              <li>Algunos creen que esta disputa es solo un intento de "marcar territorio".</li>
              <li>Además del software de GNU, hay muchas otras utilidades de diferentes fuentes que probablemente merezcan ser mencionadas.</li>
              <li>La marca ‘Linux’ es mucho más popular que su alternativa.</li>
            </ul>
          </section>
        </section>
        <section>
          <section>
            <h2>Historia</h2>
            <ul style="font-size: smaller">
              <li>Conocer la historia de un sistema ayuda muchas veces a entender mejor muchas cosas:
                <ul>
                  <li>Por qué se tomaron ciertas decisiones de diseño.</li>
                  <li>Por qué se utilizaron ciertas tecnologías y no otras.</li>
                </ul>
              </li>
              <li>Una parte importante de la historia de Linux es la historia de Unix:
                <ul>
                  <li>Porque Linux es parte de la familia Unix.</li>
                  <li>∴ <strong>No se puede entender Linux a profundidad sin entender antes Unix.</strong></li>
                </ul>
              </li>
            </ul>
          </section>
          <section id="unix_i">
            <h2>Unix (I)</h2>
            <ul>
              <li>Unix nació en 1969, en los Laboratorios Bell.</li>
              <li>Su propósito era tener un SO multitarea, multiusuario, y muchas mejoras sobre SOs anteriores.</li>
              <li>El lenguaje C se inventó, en parte, para poder hacer que Unix fuera <a href="#/portabilidad">portable</a>: C y Unix son prácticamente hermanos.
                <ul><li>Unix fue reescrito en C en 1973 para hacer al sistema portable.</li></ul>
              </li>
            </ul>
          </section>
          <section>
            <h2>Paréntesis: Derecho</h2>
            <ul>
              <li>El mundo de la informática no está aislado, tiene intersecciones con otras disciplinas.</li>
              <li>Una que tiene y ha tenido efectos importantes en la historia de la informática es el <em>Derecho</em>.</li>
            </ul>
          </section>
          <section>
            <h2>¿Por qué es importante?</h2>
            <ul>
              <li>Derechos de autor: licencias, obras derivadas, copyleft, <i>fair use</i></li>
              <li>Patentes de software</li>
              <li>Protección de datos personales</li>
              <li>Leyes económicas: compañías, leyes <i>antitrust</i>.</li>
              <li>Seguridad nacional: exportación de criptografía</li>
            </ul>
          </section>
          <section>
            <h2>Algunos casos relevantes</h2>
            <ul style="font-size: smaller">
              <li>Derechos de autor:
                <ul>
                  <li>Ideas: <i>Apple Computer, Inc. v. Microsoft Corp.</i> (1994)</li>
                  <li>APIs: <i>Google LLC v. Oracle America, Inc.</i> (2021)</li>
                  <li>Distribución: <i>Metallica v. Napster, Inc.</i>, <i>A&M Records, Inc. v. Napster, Inc.</i> (2000)</li>
                </ul>
              </li>
              <li>Monopolios según la ley <i>Sherman Antitrust</i>:
                <ul>
                  <li><i>Standard Oil Co. of New Jersey v. United States</i> (1911)</li>
                  <li><i>United States v. AT&amp;T Co.</i> (1982)</li>
                  <li><i>United States v. Microsoft Corp.</i> (2001)</li>
                </ul>
              <li>GPG: <i>Bernstein v. United States</i> (1995)</li>
            </ul>
          </section>
          <section>
            <h2>Unix (II)</h2>
            <ul style="font-size: smaller;">
              <li>Los Laboratorios Bell eran parte de AT&amp;T.</li>
              <li>AT&amp;T tenía una guerra legal con el Gobierno de los Estados Unidos.</li>
              <li>Las leyes antitrust prohibían a AT&amp;T entrar al mercado de los computadores.
                <ul>
                  <li>AT&amp;T no podía vender computadores propios, por lo que licenció Unix a otros fabricantes como secreto comercial.
                  </li>
                </ul>
              </li>
              <li>El gobierno estadounidense consiguió finalmente dividir a AT&amp;T en 1983.
                <ul><li>AT&amp;T pudo entrar al mercado de los computadores, y vender Unix directamente.</li></ul>
              </li>
            </ul>
          </section>
          <section>
            <h2>GNU</h2>
            <ul style="font-size: smaller">
              <li>Richard Stallman inició el proyecto GNU en 1983, para crear una versión de un sistema Unix totalmente libre.
                <ul>
                  <li>Después, creó la Free Software Foundation en 1985…</li>
                  <li>…y la licencia libre GPL en 1989.</li>
                </ul>
              </li>
              <li>Para esa fecha, casi todos los componentes del sistema GNU estaban listos…
                <ul><li>…excepto la parte del kernel (Hurd).</li></ul>
              </li>
              <li>El caso de Hurd se debió a la inesperada dificultad para implementar bien un microkernel.</li>
            </ul>
          </section>
          <section>
            <h2>Minix</h2>
            <ul style="font-size: smaller;">
              <li>Andrew S. Tanenbaum, profesor de ciencias de la computación, creó en 1986 un sistema operativo de tipo Unix muy simple para propósitos educativos: <i>Minix</i>.
              </li>
              <li>Minix funcionaba en plataformas Intel de 16 bits.
                <ul><li>Pero Intel había ya lanzado al mercado un año antes el 80386, un procesador de 32 bits.
                </li></ul>
              </li>
              <li>Linus Torvalds tuvo contacto con el sistema durante una clase de su universidad, en 1990.</li>
              <li>La licencia de Minix permitía ver su código, pero no modificarlo.
                <ul><li>Linus empezó a escribir un kernel para utilizar las funciones de su equipo, un 386.</li></ul>
              </li>
            </ul>
          </section>
          <section>
            <h2>Inicios de Linux</h2>
            <p>Linus finalmente anunció su proyecto en agosto de 1991, en el grupo de noticias comp.os.minix:</p>
            <ul>
              <li>Linux inicialmente tenía una licencia privativa.
                <ul><li>En diciembre de 1992 finalmente cambió a la licencia GPLv2.</li></ul>
              </li>
              <li>Este cambio permitió que los desarrolladores del proyecto GNU adoptaran Linux como kernel del proyecto.</li>
            </ul>
          </section>
        </section>
        <section>
          <section>
            <h2>Regresando a Unix…</h2>
            <ul>
              <li>Como dijimos, Linux es un sistema Unix.
                <ul>
                  <li>¿Qué significa ser un sistema Unix?</li>
                  <li>¿Existe acaso una definición formal que nos diga si algo es o no un sistema Unix?
                    <ul>
                      <li><strong>POSIX</strong>: estándar de la IEEE.</li>
                      <li><strong>Single Unix Specification</strong>:  certificación mantenida por el consorcio The Open Group.</li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
          </section>
          <section>
            <h2>POSIX</h2>
            <ul style="font-size: smaller">
              <li>Siglas de <em>Portable Operating System Interface</em>.</li>
              <li>Define varias interfaces para mantener la compatibilidad entre sistemas Unix:
                <ul>
                  <li>Biblioteca C POSIX</li>
                  <li>Servicios esenciales: tuberías, señales, procesos y operaciones de archivos.</li>
                  <li>Extensiones de tiempo real: relojes, asincronía, semáforos, planificación.</li>
                  <li>Extensiones de hilos</li>
                  <li>Comandos y utilidades: la shell, comandos como awk, echo, ed, etc.</li>
                </ul>
              </li>
            </ul>
          </section>
          <section>
            <h2>Marca Unix</h2>
            <ul>
              <li>Actualmente, la marca <i>Unix</i> es propiedad de The Open Group.</li>
              <li>Novell solo permite usar la marca a aquellos que cumplan la certificación SUS, y hayan pagado las regalías.
              </li>
              <li>Coloquialmente, llamamos <em>sistema Unix</em> a cualquier SO que cumpla todos o la mayoría de los requisitos, estén certificados o no: la <strong>familia Unix-like</strong>.
              </li>
            </ul>
          </section>
          <section>
            <h2>Unixes más populares</h2>
            <p>Unix es actualmente la familia de SOs más utilizada en el mundo, y se suelen agrupar en dos grupos:</p>
            <ul>
              <li><strong>Sistemas UNIX certificados:</strong> Hay varios SO comerciales que están certificados.</li>
              <li><strong>Sistemas no certificados</strong> o <strong>sistemas Unix-like:</strong> Otros no están certificados, pero aún así, son prácticamente sistemas Unix, por cumplir la mayoría o todos los requisitos que establece la SUS.
              </li>
            </ul>
          </section>
          <section>
            <h2>Certificados</h2>
            <ul>
              <li><strong>Solaris: </strong>versión de Sun/Oracle.
              <ul><li>Existe una versión libre: <strong>Illumos</strong></li></ul></li>
              <li><strong>AIX: </strong>versión de IBM.</li>
              <li><strong>HP-UX: </strong>versión de Hewlett-Packard.</li>
              <li><strong>macOS: </strong>versión de Apple</li>
            </ul>
          </section>
          <section>
            <h2>No certificados</h2>
            <ul style="font-size: smaller;">
              <li><strong>Familia BSD: </strong>basados en la implementación de la Universidad de Berkeley:
                <ul>
                  <li><strong>FreeBSD: </strong>el integrante más famoso, de propósito general.</li>
                  <li><strong>OpenBSD: </strong>enfocado en la seguridad: ¡solo ha tenido dos agujeros de seguridad en muchos años!
                  </li>
                  <li><strong>NetBSD: </strong>enfocado en ser portable: ¡se puede ejecutar en más de 50 arquitecturas!</li>
                </ul>
              </li>
              <li><strong>Familia GNU/Linux: </strong> los que usan el kernel Linux:
                <ul>
                  <li><strong>Distros basadas en Debian: </strong>como Ubuntu, Mint o Knoppix.</li>
                  <li><strong>Distros basadas en Red Hat: </strong>como Fedora, Mandriva o CentOS.</li>
                  <li><strong>Distros basadas en Arch Linux: </strong>como Manjaro o Antergos.</li>
                </ul>
              </li>
            </ul>
          </section>
          <section>
            <h2>Línea de tiempo de Unix</h2>
            <img class="r-stretch" style="filter: drop-shadow(white 0px 0px 8px);" src="https://upload.wikimedia.org/wikipedia/commons/c/cd/Unix_timeline.en.svg" alt="Sistemas Unix" />
          </section>
        </section>
        <section>
          <section>
            <h2>Estructura general de un sistema Linux</h2>
            <table class="not-reveal">
              <tr style="background: #fff2cc;">
                <th scope="row" rowspan="4" style="background: #d9d9d9;">Espacio de usuario</th>
                <th scope="row">Aplicaciones de usuario</th>
                <td colspan="5">bash, LibreOffice, GIMP, Firefox</td>
              </tr>
              <tr style="background: #c9daf8;">
                <th scope="row">Componentes del sistema</th>
                <td>init: <br />OpenRC, runit, systemd</td>
                <td>Demonios de sistema:<br />polkitd, smbd, sshd, udevd</td>
                <td>Sistema de ventanas:<br />X11, Wayland, SurfaceFlinger</td>
                <td>Gráficos:<br />Mesa, Catalyst</td>
                <td>Otras bibliotecas:<br />GTK, Qt…</td>
              </tr>
              <tr style="background: #d9ead3;">
                <th scope="row" rowspan="2">Biblioteca estándar de C</th>
                <td colspan="5">fopen, execv, malloc, memcpy, localtime, pthread_create, …</td>
              </tr>
              <tr style="background: #d9ead3;">
                <td colspan="5">glibc, musl, uClibc, bionic…</td>
              </tr>
              <tr style="background: #f4cccc;">
                <th scope="row" rowspan="3" style="background: #d9d9d9;">Espacio de kernel</th>
                <th scope="row" rowspan="3">Kernel Linux</th>
                <td colspan="5">System Call Interface:<br />stat, splice, dup, read, open, ioctl, write, mmap, close, exit, …<br />cerca de 380 llamadas al sistema</td>
              </tr>
              <tr style="background: #f4cccc;">
                <td>Planificación</td>
                <td>IPC</td>
                <td>Administración de memoria</td>
                <td>Sistemas de archivos virtuales</td>
                <td>Red</td>
              </tr>
              <tr style="background: #f4cccc;">
                <td colspan="5">Otros componentes:<br />ALSA, DRI, evdev, klibc, LVM, device mapper, Linux Network Scheduler, Netfilter<br />Linux Security Modules: SELinux, TOMOYO, AppArmor, Smack</td>
              </tr>
              <tr style="background: #b7b7b7">
                <td colspan="7" style="font-weight: bold;">Hardware</td>
              </tr>
            </table>
          </section>
          <section>
            <h2>¿Espacios de kernel y usuario? (I)</h2>
            <ul>
              <li>Se refiere a los dos tipos de privilegios que un proceso puede tener.</li>
              <li>Espacio de kernel: 
                <ul>
                  <li>El propio kernel, la mayoría de controladores de dispositivo.</li>
                  <li>Tiene acceso al espacio de memoria real.</li>
                </ul>
              </li>
            </ul>
          </section>
          <section>
            <h2>¿Espacios de kernel y usuario? (II)</h2>
            <ul>
              <li>Espacio de usuario (<i>userland</i>):
                <ul>
                  <li>Aplicaciones del usuario comunes.</li>
                  <li>Cada proceso corre en su propio espacio de memoria virtual.</li>
                  <li>No puede acceder a la memoria de otros procesos sin autorización.
                    <ul><li>Puede pedirse autorización para compartir memoria con otro proceso.</li></ul>
                  </li>
                </ul>
              </li>
            </ul>
          </section>
          <section>
            <h2>Anillos de protección (I)</h2>
            <ul style="font-size: smaller">
              <li>Normalmente, lo anterior se implementa sobre los anillos de protección del procesador.
                <ul><li>La arquitectura x86 contempla 4 anillos de protección (0-3).</li></ul>
              </li>
              <li>Y a su vez, los anillos de protección se implementan sobre los modos de CPU:
                <ul><li>El 80386 es el primer procesador de la familia en incluir modos de ejecución (modo real, protegido y virtual).
                </li></ul>
              </li>
            </ul>
          </section>
          <section>
            <h2>Anillos de protección (I)</h2>
            <img class="r-stretch" style="filter: drop-shadow(white 0px 0px 8px);" src="https://upload.wikimedia.org/wikipedia/commons/2/2f/Priv_rings.svg" alt="Anillos de potección" />
          </section>
          <section>
            <h2>Fallas en el mecanismo de protección (I)</h2>
            <div class="cont-img">
              <ul>
                <li>Muchos ataques de escalamiento de privilegios aprovechan fallas en el código que corre en modo privilegiado.
                  <ul><li>Por ejemplo, código privilegiado que inadvertidamente carga código malicioso.</li></ul>
                </li>
              </ul>
              <img style="width: 200px;" src="https://upload.wikimedia.org/wikipedia/commons/8/86/Meltdown_logo_with_text.svg" alt="logo de Meltdown" />
            </div>
          </section>
          <section>
            <h2>Fallas en el mecanismo de protección (II)</h2>            
            <div class="cont-img">
              <ul>
                <li>Otros ataques van más allá, y atacan directamente al mecanismo de protección del microprocesador:
                  <ul>
                    <li>Meltdown: la caché de una operación de lectura</li>
                    <li>Spectre: la predicción de saltos</li>
                  </ul>
                </li>
              </ul>
              <img style="width: 200px;" src="https://upload.wikimedia.org/wikipedia/commons/9/94/Spectre_logo_with_text.svg" alt="logo de Spectre" />
            </div>
          </section>
          <section>
            <h2>Meltdown (I)</h2>
            <ul style="font-size: smaller;">
              <li>Se basa en aprovechar una condición de carrera entre la ejecución de una instrucción, y la comprobación de privilegios, para leer regiones de memoria a la que no está autorizado.
                <ul>
                  <li>Normalmente, una instrucción que intente leer memoria no autorizada hará que el controlador de memoria dé inicio a la operación.</li>
                  <li>Aunque el planificador intervendrá más adelante, al comprobar la ilegalidad, y el dato no llegará al proceso.
                    <ul><li><strong>Pero la caché de la CPU será actualizada con el valor leído igualmente.</strong></li></ul>
                  </li>
                </ul>
              </li>
            </ul>
          </section>
          <section>
            <h2>Meltdown (II)</h2>
            <ul style="font-size: smaller;">
              <li>Normalmente, la caché de la CPU no es accesible a procesos no autorizados.
                <ul><li>Pero podemos suponer que el valor de una dirección ha sido guardada en caché.</li></ul>
              </li>
              <li>Podemos intentar medir la velocidad con la que se leen ciertas direcciones, a través del <strong>direccionamiento indirecto por memoria</strong>, para suponer cuáles direcciones pudieron haber sido ya recientemente accedidas.
                <ul><li>Se puede usar esta dirección ‘calculada’ como valor propiamente, aunque la CPU no devuelva el dato en sí.</li></ul>
              </li>
            </ul>
          </section>
        </section>
        <section>
          <section>
            <h2>Componentes en espacio de kernel</h2>
          </section>
          <section>
            <h2>Linux Security Modules</h2>
            <ul>
              <li>Framework dentro del kernel que permite implementar modelos de seguridad.</li>
              <li>Existe desde Linux 2.6.</li>
              <li>En el kernel, permite que cuatro sistemas estén habilitados:
                <ul>
                  <li>AppArmor: Debian, Ubuntu.</li>
                  <li>SELinux: RedHat, Android.</li>
                  <li>Smack: MeeGo, Tizen.</li>
                  <li>Tomoyo Linux.</li>
                </ul>
              </li>
            </ul>
          </section>
          <section>
            <h2>Logical Volume Manager (I)</h2>
            <ul style="font-size: smaller;">
              <li>Framework dentro del kernel para la administración de volúmenes lógicos.</li>
              <li>LVM permite, entre otras cosas, lo siguiente:
                <ul>
                  <li>Crear un volúmen lógico único a partir de múltiples volúmenes físicos o discos enteros.</li>
                  <li>Manejar granjas de discos, que permitan añadir y quitar discos sin dar de baja el servicio.</li>
                  <li>Permitir el redimensionado de particiones sin problemas.</li>
                  <li>Realizar copias de seguridad con snapshots de volúmenes lógicos.</li>
                  <li>Cifrar volúmenes lógicos con una contraseña.</li>
                </ul>
              </li>
            </ul>
          </section>
          <section>
            <h2>Logical Volume Manager (II)</h2>
            <div class="cont-img">
              <p>LVM mantiene tres conceptos para organizar el sistema: <em>volúmenes y particiones físicas</em>, <em>grupos de volúmenes</em> y <em>volúmenes lógicos</em>.</p>
              <img style="width: 500px; padding-left: 1em;" src="https://upload.wikimedia.org/wikipedia/commons/e/e6/Lvm.svg" alt="Esquema de LVM" />
            </div>
          </section>
          <section>
            <h2>Netfilter</h2>
            <ul>
              <li>Framework dentro del kernel que permite realizar varias operaciones sobre la red, en forma de hooks.
              </li>
              <li>Se usa mucho para filtrado de paquetes y traducción de puertos y direcciones de red (NAT).</li>
              <li>Netfilter empezó a usarse desde estas utilidades:
                <ul>
                  <li>iptables: desde 2.4.</li>
                  <li>nftables: desde 3.13.</li>
                </ul>
              </li>
              <li>Anteriormente, las siguientes utilidades estaban en el kernel:
                <ul>
                  <li>ipfirewal/ipfw: desde 1.1.</li>
                  <li>ipchains: desde 2.2.</li>
                </ul>
              </li>
            </ul>
          </section>
          <section>
            <h2>iptables</h2>
            <ul>
              <li>iptables es la utilidad más popular para implementar cortafuegos en Linux. Está dividido en varios módulos, uno para cada protocolo:
                <ul>
                  <li><i>iptables</i> para IPv4.</li>
                  <li><i>ip6tables</i> para IPv6.</li>
                  <li><i>arptables</i> para ARP.</li>
                  <li><i>ebtables</i> para tramas Ethernet.</li>
                </ul>
              </li>
              <li>Básicamente, para cada protocolo, se definen <em>tablas</em>, que contienen <em>cadenas</em> con <em>reglas</em> para tratar los paquetes.</li>
              <li>Normalmente, la tabla que nos interesa es <i>filter</i>.</li>
            </ul>
          </section>
          <section>
            <h2>iptables: cadenas</h2>
            <ul style="font-size: smaller">
              <li>En cada tabla se implementan cinco cadenas, según el destino del paquete:
                <dl class="lista-natural">
                  <dt><code>PREROUTING</code></dt><dd>Paquetes antes de evaluarse su destino.</dd>
                  <dt><code>INPUT</code></dt><dd>Paquetes a ser entregados en el dispositivo.</dd>
                  <dt><code>FORWARD</code></dt><dd>Paquetes a ser reenrutados.</dd>
                  <dt><code>OUTPUT</code></dt><dd>Paquetes a ser enviados.</dd>
                  <dt><code>POSTROUTING</code></dt><dd>Paquetes después de ser evaluados.</dd>
                </dl>
              </li>
              <li>Corresponden a los cinco hooks predeterminados de Netfilter, aunque puede que una tabla no las use todas.</li>
            </ul>
          </section>
          <section>
            <h2>iptables: reglas</h2>
            <ul>
              <li>Las reglas contienen las condiciones de los paquetes que coinciden, y un destino, o un veredicto.</li>
              <li>Cada regla puede tener tres posibles <em>veredictos</em>:
                <dl class="lista-natural">
                  <dt><code>ACCEPT</code></dt><dd>Se permite que el paquete avance.</dd>
                  <dt><code>DROP</code><dd>El paquete se descartará.</dd>
                  <dt><code>REJECT</code><dd>El paquete es rechazado, y seinforma de ello.</dd>
                </dl>
              </li>
              <li>Cada cadena de las anteriores tiene una <em>política</em>: una regla predeterminada para los paquetes que no coinciden con ninguna regla de la cadena.</li>
            </ul>
          </section>
          <section>
            <h2>Ejemplo de reglas</h2>
            <pre class="iptables"><code data-line-numbers="" style="white-space: pre-wrap">iptables -F INPUT
iptables -A INPUT -m state --state ESTABLISHED -j ACCEPT
iptables -A INPUT -m state --state NEW -i lo -j ACCEPT
iptables -A INPUT -m state --state NEW -i eth0 -p tcp -m multiport --dports 21,22,53,80,139,515,3128,8080 -j ACCEPT
iptables -A INPUT -m state --state NEW -i eth0 -p udp -m multiport --dports 53,137,138,3130 -j ACCEPT
iptables -P INPUT DROP

iptables -F FORWARD
iptables -P FORWARD DROP

iptables -F OUTPUT
iptables -P OUTPUT ACCEPT</code></pre>
          </section>
          <section>
            <h2>Advanced Linux Sound Architecture</h2>
            <ul style="font-size: smaller;">
              <li>Framework dentro del kernel que provee una interfaz para implementar controladores para tarjetas de audio.</li>
              <li>Reemplaza a la antigua implementación de Open Sound System.</li>
              <li>Permite manejar múltiples canales de audio, y aprovechar la capacidad multiprocesamiento y multihilo.</li>
              <li>Los <em>servidores de audio</em> usan ALSA por debajo para usar el hardware:
                <ul style="column-count: 4;">
                  <li>sndio</li>
                  <li>PulseAudio</li>
                  <li>JACK</li>
                  <li>PipeWire</li>
                </ul>
              </li>
            </ul>
          </section>
        </section>
        <section>
          <section>
            <h2>Componentes en espacio de usuario</h2>
          </section>
          <section>
            <h2>init</h2>
            <ul>
              <li>Después de cargar el kernel, éste es el primer proceso lanzado, y el que inicia a todos los demás.</li>
              <li>Adquiere el <strong>PID</strong> 1, y si el proceso no puede ser iniciado, ocurre un <b>kernel panic</b>.</li>
              <li>Existen varios demonios que realizan esta función:
                <ul>
                  <li>systemd</li>
                  <li>openRC</li>
                </ul>
              </li>
            </ul>
          </section>
          <section>
            <h2>systemd</h2>
            <ul>
              <li>Es un framework que provee diversos componentes del sistema.
                <ul>
                  <li>Su intención es unificar la forma en la que los sistemas Linux implementan y configuran los servicios.</li>
                  <li>Su principal función es la de proveer el sistema init.</li>
                </ul>
              </li>
              <li>La mayor parte de las distribuciones Linux han adoptado systemd.
                <ul>
                  <li>Aunque existen críticas sobre su amplio alcance:
                    <ul><li>Existen distros que evitan systemd: Devuan</li></ul>
                  </li>
                </ul>
              </li>
            </ul>
          </section>
          <section>
            <h2>Componentes de systemd</h2>
            <p>Además de funcionar como sistema init, los siguientes demonios pueden estar incluidos:</p>
            <ul>
              <li><strong>journald:</strong> registro de eventos.</li>
              <li><strong>localed:</strong> <i>locales.</i></li>
              <li><strong>logind:</strong> sesiones de usuario.</li>
              <li><strong>hostnamed:</strong> hostname.</li>
              <li><strong>networkd:</strong> configuración de interfaces de red.</li>
              <li><strong>resolved:</strong> resolución de nombres local.</li>
              <li><strong>tmpfiles:</strong> gestión de archivos temporales.</li>
              <li><strong>udevd:</strong> administrador de dispositivos.</li>
            </ul>
          </section>
          <section>
            <h2>cron</h2>
            <ul>
              <li>Un planificador de tareas (o job scheduler) es el sistema que permite al sistema operativo ejecutar tareas desatendidamente cuando se den ciertas condiciones.
                <ul>
                  <li>Normalmente, condiciones temporales.</li>
                  <li>No confundir con el <i>planificador de procesos</i>, parte integral de cualquier sistema operativo multitarea.</li>
                </ul>
              </li>
              <li>En Windows, tenemos a <i>at</i>, a <i>cron</i>, y a <i>Windows Task Scheduler</i>.</li>
              <li>En Unix, el planificador de tareas predeterminado es <strong>cron</strong>.</li>
            </ul>
          </section>
          <section>
            <h2>crontab</h2>
            <ul>
              <li>Las tareas que cron reconoce son especificadas en unos archivos de texto, conocidos colectivamente como crontabs.
                <ul><li>Existe un crontab para el sistema, y pueden existir también uno para cada usuario.</li></ul>
              </li>
            </ul>
            <pre><code># ┌───────────── minute (0–59)
# │ ┌───────────── hour (0–23)
# │ │ ┌───────────── day of the month (1–31)
# │ │ │ ┌───────────── month (1–12)
# │ │ │ │ ┌───────────── day of the week (0–6) (Sunday to Saturday;
# │ │ │ │ │              7 is also Sunday on some systems)
# │ │ │ │ │
# │ │ │ │ │
# * * * * * [comando a ejecutar]</code></pre>
          </section>
        </section>
        <section>
          <section>
            <h2>Red</h2>
            <p>En los sistemas Linux, la configuración de la red se logra mediante la conjunción de varios sistemas, describimos algunos aquí.</p>
          </section>
          <section>
            <h2>NetworkManager</h2>
            <div class="cont-img">
              <ul style="font-size: smaller;">
                <li>El demonio más utilizado para administrar y configurar interfaces de red.</li>
                <li>El demonio está atento a cambios en el hardware, y en las condiciones de red; e informa a los clientes conectados.</li>
                <li>La configuración se encuentra en <code>/etc/NetworkManager/NetworkManager.conf</code></li>
              </ul>
              <img src="https://upload.wikimedia.org/wikipedia/commons/9/9e/GNOME_Shell_NM_front-end_3.10.png" alt="NetworkManager frontend" style="width: 500px;" />
            </div>
          </section>
          <section>
            <h2>wpa_supplicant</h2>
            <ul>
              <li>Es la implementación más utilizada de un <i>supplicant</i> IEEE 802.11i.
                <ul>
                  <li>La norma IEEE 802.11i es la que estandariza el protocolo WPA, para redes WiFi seguras.</li>
                  <li>Un <i>supplicant</i>, en el contexto de las redes WiFi, es un dispositivo o sistema en busca de ser autentificado.</li>
                </ul>
              </li>
              <li>Su archivo de configuración se encuentra en <code>/etc/wpa_supplicant/wpa_supplicant.conf</code>.</li>
            </ul>
          </section>
          <section>
            <h2>wpa_supplicant: ejemplo</h2>
            <pre><code>ctrl_interface=/run/wpa_supplicant
ctrl_interface_group=wheel
update_config=1
ap_scan=1
country=US

network={
    ssid="MYSSID"
    psk=59e0d07fa4c7741797a4e394f38a5c321e3bed51d54ad5fcbd3f84bc7415d73d
}</code></pre>
          </section>
          <section>
            <h2>netplan</h2>
            <ul>
              <li>Desde Ubuntu 17.10, este componente viene preinstalado para configurar muchos aspectos de la red.</li>
              <li>Se basa en archivos YAML, almacenados en <code>/etc/netplan/</code>.</li>
            </ul>
          </section>
          <section>
            <h2>netplan: ejemplo</h2>
            <pre class="yaml"><code>network:
  version: 2
  renderer: networkd
  ethernets:
    enp3s0:
      dhcp4: no
      addresses:
        - 192.168.0.37/24
      nameservers:
        search: [mydomain, otherdomain]
        addresses: [8.8.8.8, 1.1.1.1]
      routes:
        - to: default
          via: 192.168.0.1</code></pre>
          </section>
        </section>
        <section>
          <section>
            <h2>Entorno gráfico</h2>
            <ul>
              <li>La forma tradicional de comunicarse con el sistema operativo es a través de una shell de texto.
                <ul><li>Pero también podemos tener shells gráficos.</li></ul>
              </li>
              <li>A diferencia de otros sistemas, como Windows, los componentes gráficos no están integrados en el sistema, y éstos pueden no existir.</li>
              <li>Tener una sesión gráfica implica el uso de varios componentes que deben trabajar juntos, siguiendo varios protocolos.</li>
            </ul>
          </section>
          <section>
            <h2>Sistema de ventanas (I)</h2>
            <ul>
              <li>Es el programa (o conjunto de programas) que maneja el dibujado de los elementos de una GUI en una pantalla. Específicamente, el paradigma WIMP.</li>
              <li>Tiene dos componentes principales: el <strong>servidor de ventanas</strong>, un programa que "escucha" peticiones de <strong>clientes</strong>, para dibujar elementos en la pantalla; y devuelve al cliente la entrada del usuario.</li>
            </ul>
          </section>
          <section>
            <h2>Sistema de ventanas (II)</h2>
            <ul>
              <li>En este nivel, <i>ventana</i> es solo un recuadro en donde dibujar.</li>
              <li>Sistemas de ventanas más comunes:
                <ul>
                  <li><strong>X11:</strong> el más usado actualmente.</li>
                  <li><strong>Wayland:</strong> una alternativa algo menos popular.</li>
                  <li><strong>Mir:</strong> un intento de Canonical.</li>
                </ul>
              </li>
            </ul>
          </section>
          <section>
            <h2>X11</h2>
            <ul>
              <li>El sistema de ventanas más común en sistemas Unix.</li>
              <li>Provee un framework para dibujar ‘primitivas’: componentes para mover y dibujar ventanas, y eventos del ratón y el teclado.</li>
              <li>Soporta conexiones a través de la red.</li>
              <li>Implementaciones:
                <ul>
                  <li><strong>X.Org</strong>: la implementación de referencia en estos días.</li>
                  <li><strong>XFree86</strong>: la más popular hasta 2004.</li>
                </ul>
              </li>
            </ul>
          </section>
          <section>
            <h2>Administrador de ventanas</h2>
            <ul>
              <li>O <i>window manager</i>, el sistema que permite al usuario manipular ventanas.
                <ul>
                  <li>Moverlas, cerrarlas, maximizarlas, etc.</li>
                  <li>Dibuja los <em>decorados de ventana</em>.</li>
                  <li>Provee el menú contextual.</li>
                </ul>
              </li>
              <li>Puede tener otros elementos asociados: barras de tareas o docks, para controlar ventanas en uso, espacios de trabajo, fondos de escritorio…
              </li>
            </ul>
          </section>
          <section>
            <h2>Administrador de ventanas: tipos</h2>
            <dl class="lista-natural">
              <dt>Compositing WM</dt><dd>Ventanas creadas por compositores con efectos 2D y 3D.</dd>
              <dt>Stacking WM</dt><dd>Ventanas que pueden dibujarse unas sobre otras.</dd>
              <dt>Tiling WM</dt><dd>Ventanas acomodadas en mosaico.</dd>
              <dt>Dynamic WM</dt><dd>La que puede aplicar más de un tipo anterior.</dd>
            </dl>
          </section>
          <section>
            <h2>Administrador de ventanas: ejemplos</h2>
            <div class="cont-img">
              <ul style="font-size: smaller;">
                <li>Desktop Window Manager/dwm.exe</li>
                <li>Enlightenment</li>
                <li>IceWM</li>
                <li>KWin (KDE)</li>
                <li>Metacity (Gnome 2)</li>
                <li>Mutter (Gnome 3)</li>
                <li>Openbox (LXDE)</li>
                <li>wmii</li>
                <li>xfwm (xfce)</li>
              </ul>
              <img style="width: 500px;" src="https://upload.wikimedia.org/wikipedia/commons/f/f8/Windowmanager_ohne.png" alt="Ventanas sin administrador de ventanas" />
            </div>
          </section>
          <section>
            <h2>Entorno de escritorio</h2>
            <ul style="font-size: smaller;">
              <li>La implementación completa de la <em>metáfora de escritorio</em>.</li>
              <li>Consiste, como mínimo, en un administrador de ventanas, y habitualmente, en toda la distribución de programas diseñados para trabajar en conjunto con ese administrador.</li>
            </ul>
            <div class="galeria">
              <figure>
                <img src="https://upload.wikimedia.org/wikipedia/commons/e/e5/Elementary_OS_7.0_Horus.jpg" alt="Pantheon" />
                <figcaption>Pantheon</figcaption>
              </figure>
              <figure>
                <img src="https://upload.wikimedia.org/wikipedia/commons/3/3d/Ubuntu_Unity_22.10_desktop_screenshot.png" alt="Unity" />
                <figcaption>Unity</figcaption>
              </figure>
            </div>
          </section>
          <section>
            <h2>Entornos de escritorio</h2>
            <ul style="column-count: 3;">
              <li>Gnome</li>
              <li>KDE Plasma</li>
              <li>Cinnamon</li>
              <li>Unity</li>
              <li>Mate</li>
              <li>LXDE/LXQt</li>
              <li>Xfce</li>
              <li>Windows Shell</li>
            </ul>
            <div class="galeria">
              <figure>
                <img style="height: 300px;" src="https://upload.wikimedia.org/wikipedia/commons/4/4c/LXDE_desktop_full.png" alt="LXDE" />
                <figcaption>LXDE</figcaption>
              </figure>
              <figure>
                <img style="height: 300px;" src="https://upload.wikimedia.org/wikipedia/commons/7/78/Solus_4.1_Budgie.jpg" alt="Budgie" />
                <figcaption>Budgie</figcaption>
              </figure>
            </div>
          </section>
          <section>
            <h2>Ejemplo de entorno: LXDE</h2>
            <ul style="font-size: smaller;">
              <li><em>¿Por qué de ejemplo?</em> Es bastante modular.</li>
              <li>Diseñado para consumir pocos recursos.</li>
              <li>Componentes:
                <ul>
                  <li>Administrador de archivos: PCManFM</li>
                  <li>Lanzador: LXLauncher</li>
                  <li>Panel: LXPanel</li>
                  <li>Visor de imágenes: GPicView</li>
                  <li>Administrador de pantallas: LXDM</li>
                  <li>Editor de texto: Leafpad</li>
                  <li>Administrador de ventanas: Openbox</li>
                </ul>
              </li>
            </ul>
          </section>
          <section>
            <h2>Gestor de pantallas X (I)</h2>
            <ul style="font-size: smaller;">
              <li>En general, cuando un sistema tiene una instancia de un servidor X, se espera iniciar esta sesión gráfica cuanto antes.
                <ul>
                  <li>Esto es, antes incluso del inicio de sesión.</li>
                </ul>
              </li>
              <li>X no maneja la autentificacion de forma predeterminada.
                <ul>
                  <li>El componente que se encarga de eso es el <strong>gestor de pantallas</strong>, o <i>display manager</i>.</li>
                </ul>
              </li>
              <li>El gestor de pantallas inicia al servidor X antes de iniciar sesión, y después, presenta la pantalla de sesión.</li>
            </ul>
          </section>
          <section>
            <h2>Gestor de pantallas X (II)</h2>
            <ul style="column-count: 2;">
              <li>GDM (Gnome)</li>
              <li>LightDM</li>
              <li>SDDM (KDE, LXQt)</li>
              <li>XDM</li>
            </ul>
            <div class="galeria" style="height: 300px;">
              <figure>
                <img src="https://upload.wikimedia.org/wikipedia/commons/6/6d/Fedora_21_login_screen.png" alt="gdm" />
                <figcaption>gdm</figcaption>
              </figure>
              <figure>
                <img src="https://upload.wikimedia.org/wikipedia/commons/d/d4/Fedora_login_screen.png" alt="lightdm" />
                <figcaption>lightdm</figcaption>
              </figure>
            </div>
          </section>
          <section>
            <h2>Widget</h2>
            <p>El elemento principal en una interfaz gráfica es el <strong>widget</strong>, un elemento gráfico que permite interactuar con la aplicación de alguna forma.</p>
            <ul>
              <li>Botones</li>
              <li>Campos de texto</li>
              <li>Combos</li>
              <li>Casillas</li>
              <li>Cuadros de diálogo</li>
              <li>Radiobotones</li>
            </ul>
          </section>
          <section>
            <h2>Biblioteca de widgets (I)</h2>
            <ul>
              <li>Salvo en muy pocas ocasiones, no dibujamos a mano los widgets de nuestra aplicación:
                <ul>
                  <li>Esa tarea la realiza una <strong>biblioteca de widgets</strong> o <i>widget toolkit</i>.
                  </li>
                  <li>Las bibliotecas de widgets mantienen un estilo consistente entre todos sus elementos.</li>
                </ul>
              </li>
            </ul>
          </section>
          <section>
            <h2>Biblioteca de widgets (II)</h2>
            <p>Muchos widgets son multiplataforma, no dependen del sistema operativo:</p>
            <ul>
              <li>GTK</li>
              <li>Qt</li>
              <li>wxWidgets</li>
              <li>Kivy</li>
              <li>Tk</li>
            </ul>
          </section>
          <section>
            <h2>Biblioteca de widgets (III)</h2>
            <p>Los sistemas operativos que incluyen de serie sistemas gráficos incluyen también una biblioteca de widgets.</p>
            <ul style="font-size: smaller; column-count: 2;">
              <li>Microsoft Windows
                <ul>
                  <li>Win32 API
                    <ul>
                      <li>Microsoft Foundation Classes</li>
                      <li>Windows Template Library</li>
                      <li>Windows Presentation Foundation</li>
                    </ul>
                  </li>
                  <li>Windows UI Library</li>
                </ul>
              </li>
              <li>Mac OS/OS X
                <ul>
                  <li>Carbon</li>
                  <li>Cocoa</li>
                </ul>
              </li>
            </ul>
          </section>
          <section>
            <h2>Cargador de arranque</h2>
            <ul>
              <li>O <i>bootloader</i>, primer componente ejecutado por la CPU al operar.</li>
              <li>Es la encargada de cargar el kernel Linux en la memoria principal.
                <ul>
                  <li>GRUB</li>
                  <li>LILO</li>
                  <li>SYSLINUX</li>
                  <li>gummiboot/systemd-boot</li>
                </ul>
              </li>
            </ul>
          </section>
          <section>
            <h2>Otros sistemas</h2>
            <ul>
              <li><strong>CUPS</strong>: framework para servir impresoras.</li>
              <li><strong>FUSE</strong>: <i>Filesystem in Userspace</i>.</li>
              <li><strong>SSH</strong>: sistema para conexiones remotas seguras.</li>
              <li><strong>VNC</strong>: sistema para escritorios remotos.</li>
              <li>Servidores: Web, correo, proxy, etc...</li>
            </ul>
          </section>
        </section>
        <!--SEGUNDO TEMA-->
        <section>
          <section id="segundotema">
            <h2>Tema 2:<br />Sistemas de Archivos</h2>
          </section>
          <section>
            <h2>Antecedentes</h2>
            <div class="cont-img">
              <ul style="font-size: smaller;">
                <li><strong>Todo es una secuencia o 'stream' de bytes</strong>.</li>
                <li>Los primeros dispositivos no reconocían archivos, solo almacenaban conjuntos de datos:
                  <ul>
                    <li><i>Analógicos</i>: discos de vinilo, cintas de casette.</li>
                    <li>En el nivel más bajo, los dispositivos <i>digitales</i> también almacenan solamente bytes.</li>
                  </ul>
                </li>
              </ul>
              <div>
                <img style="width: 400px;" src="images/vinilos.png" alt="discos de vinilo" />
                <img style="width: 400px;" src="images/casette.png" alt="casette" />
              </div>
            </div>
          </section>
        </section>
        <section>
          <section>
            <h2>¿Qué es un archivo?</h2>
            <p><strong>Abstracción o TAD que el SO propone para un conjunto de bytes en un dispositivo.</strong></p>
            <ul>
              <li>El SO expone funciones al usuario para poder manipular el contenido de un archivo (o sea, los bytes asociados) sin preocuparse de cómo se guardan éstos en el dispositivo.</li>
            </ul>
          </section>
          <section>
            <h2>Operaciones sobre archivos</h2>
            <ul>
              <li>Crear (create)</li>
              <li>Borrar (delete)</li>
              <li>Abrir (open)</li>
              <li>Cerrar (close)</li>
              <li>Leer (read)</li>
              <li>Escribir (write, flush)</li>
              <li>Reposicionar (seek)</li>
            </ul>
          </section>
          <section>
            <h2>Archivos de texto y binarios</h2>
            <p><strong>Los <em>archivos de texto</em> son archivos binarios que solo contienen un subconjunto de bytes, los que representan caracteres imprimibles.</strong></p>
            <ul>
              <li>Tradicionalmente, el conjunto de caracteres imprimibles ASCII.
                <ul>
                  <li>Ahora, con la adopción de Unicode, cualquier caracter Unicode válido que no sea un caracter de control.</li>
                  <li>Aunque depende del contexto.</li>
                </ul>
              </li>
            </ul>
          </section>
          <section>
            <h2>Formato de archivo</h2>
            <div class="cont-img">
              <ul>
                <li>Los datos dentro de un archivo pueden estar ordenados de mil formas distintas, y corresponde a quien los crea decidir el orden de los datos en un archivo.</li>
                <li>El formato de un tipo de archivo específico puede estar reglamentado por un estándar o especificación.</li>
              </ul>
              <div>
                <img style="width: 400px" src="images/texto.png" alt="archivo de texto" />
                <img style="width: 400px" src="images/word.png" alt="archivo de texto 2" />
              </div>
            </div>
          </section>
          <section>
            <h2>Formatos libres y privativos</h2>
            <ul>
              <li>Existen formatos cuya especificación es libre y otros cuya especificación no lo es.</li>
              <li>Existen formatos documentados, documentados a medias, no documentados...</li>
              <li>Generalmente, los formatos libres están bien documentados.</li>
            </ul>
          </section>
          <section>
            <h2>¿Cómo determinar el tipo de un archivo?</h2>
            <ul>
              <li>Extensiones de archivo.
                <ul>
                  <li>Implementados originalmente por CP/M.
                    <ul><li>Y, por consiguiente, MS/DOS y Windows.</li></ul>
                  </li>
                </ul>
              </li>
              <li>Metadatos asociados a un archivo.
                <ul><li>Mac OS y typecodes.</li></ul>
              </li>
              <li>Números mágicos.
                <ul><li>Forma seguida por los sistemas Unix.</li></ul>
              </li>
            </ul>
          </section>
        </section>
        <section>
          <section>
            <h2>Sistemas de archivos</h2>
          </section>
          <section>
            <h2>¿Qué son?</h2>
            <p><strong>Los sistemas de archivos organizan archivos.</strong></p>
            <ul>
              <li>Algunos sistemas de archivos buscan redundancia, mayor rapidez, tolerancia a fallos o protección por cifrado.</li>
              <li>Permiten guardar diversos datos sobre los archivos: <strong>metadatos</strong>:
                <ul>
                  <li>Nombre, permisos, fechas (de acceso, de modificación), si son de alguna categoría especial, etc.</li>
                  <li><strong>Ruta de archivo:</strong> existente para prácticamente cualquier SO.</li>
                </ul>
              </li>
            </ul>
          </section>
          <section>
            <h2>Terminología</h2>
            <p>Hay qué diferenciar entre dos usos del término:</p>
            <ul>
              <li>El más común, que acabamos de ver: el de una estructura particular para organizar archivos, y datos sobre estos archivos.</li>
              <li>Ocasionalmente, llamamos también así al sistema subyacente que tiene el kernel para reconocer archivos.
                <ul>
                  <li>Los sistemas de archivos de la primera definición usan como base este sistema.</li>
                </ul>
              </li>
            </ul>
          </section>
          <section>
            <h2>¿Cuáles existen?</h2>
            <ul style="column-count: 2;">
              <li>FAT
                <ul>
                  <li>FAT16</li>
                  <li>FAT32</li>
                  <li>exFAT</li>
                </ul>
              </li>
              <li>NTFS</li>
              <li>ext*
                <ul>
                  <li>ext2</li>
                  <li>ext3</li>
                  <li>ext4</li>
                </ul>
              </li>
              <li>HFS
                <ul><li>HFS+</li></ul>
              </li>
              <li>UFS</li>
              <li>ZFS</li>
              <li>btrfs</li>
              <li>cdfs
                <ul><li>UDF (ISO 9600)</li></ul>
              </li>
            </ul>
          </section>
          <section>
            <h2>Analogía del archivero</h2>
            <ul>
              <li>En general, la abstracción del sistema de archivos se parece a un <i>archivero de oficina</i> en la vida real.</li>
              <li>La nomenclatura puede variar un poco, dependiendo del enfoque y del tipo de usuario final: <i>directorios</i> en Unix vs <i>carpetas</i> en Windows.</li>
            </ul>
          </section>
        </section>
        <section>
          <section>
            <h2>Organización de archivos</h2>
            <ul style="font-size: smaller;">
              <li>En un sistema de archivos generalmente queremos guardar <em>muchos</em> archivos.
                <ul>
                  <li>Para manejarlos, debemos establecer una forma de organizarlos.</li>
                </ul>
              </li>
              <li>Podemos clasificar los sistemas de archivos según su forma de organizar archivos:
                <ul>
                  <li>Sistemas planos.
                    <ul><li>A pesar de lo simple, aún se usan: Amazon S3.</li></ul>
                  </li>
                  <li>Sistemas con etiquetas.</li>
                  <li>Sistemas de profundidad fija.</li>
                  <li>Sistemas con <strong>árbol de directorios</strong>.
                    <ul>
                      <li>Nos centraremos en estos sistemas de ahora en adelante.</li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
          </section>
          <section>
            <h2>Árbol de directorios</h2>
            <ul>
              <li>El directorio es una estructura para agrupar archivos de forma jerárquica.</li>
              <li>Cada directorio está dentro de otro directorio, excepto el directorio raíz.</li>
              <li>Cada archivo o directorio tiene una <strong>ruta</strong> de búsqueda que lo identifica.</li>
              <li>Por todo lo anterior, podemos representar al sistema de archivos como un <em>grafo dirigido</em>.</li>
            </ul>
          </section>
          <section>
            <h2>Directorios especiales</h2>
            <div class="cont-img">
              <ul style="font-size: smaller;">
                <li>En muchos sistemas de archivos, cada directorio contiene dos directorios especiales:
                  <ul>
                    <li><strong>.</strong> ⇒ apunta a sí mismo</li>
                    <li><strong>..</strong> ⇒ apunta al directorio padre</li>
                  </ul>
                </li>
                <li>Excepto <strong>/..</strong>, que apunta a sí mismo, puesto que el directorio raíz no tiene padre.</li>
              </ul>
              <img src="images/grafo1.png" alt="Árbol de directorios" />
            </div>
          </section>
        </section>
        <section>
          <section>
            <h2>Inodo</h2>
            <ul>
              <li>La estructura de un sistema de archivos que describe un objeto dentro del sistema.
                <ul>
                  <li>Coloquialmente, nos referimos a estos objetos como <i>archivos</i>.</li>
                  <li>Pero, los directorios <strong>no</strong> son archivos.</li>
                </ul>
              </li>
              <li>Almacenan información sobre el objeto, y su ubicación física en el soporte.</li>
              <li>Los inodos no contienen la ruta del objeto.
                <ul>
                  <li>Como consecuencia, varias rutas pueden referir al mismo nodo.</li>
                </ul>
              </li>
            </ul>
          </section>
          <section>
            <h2>Metadatos de inodo</h2>
            <ul>
              <li>En un sistema de archivos Unix, un inodo tiene, como mínimo, los siguientes atributos:
                <ul style="column-count: 2;">
                  <li>Tipo de archivo</li>
                  <li>Contador de referencias</li>
                  <li>UID del dueño</li>
                  <li>GID del dueño</li>
                  <li><i>Device ID</i>, si el inodo es un dispositivo</li>
                  <li>Tamaño en bytes</li>
                  <li><i>ctime</i>, <i>mtime</i> y <i>atime</i></li>
                  <li>Número de bloques utilizados</li>
                </ul>
              </li>
              <li>El comando <em>stat</em> nos da datos del inodo de una ruta.</li>
            </ul>
          </section>
          <section>
            <h2>Tipos de inodo</h2>
            <p>En Unix, los inodos pueden representar varios tipos de objetos:</p>
            <ul>
              <li>Regular (-)</li>
              <li>Directorio (d)</li>
              <li>Enlace simbólico (l)</li>
              <li>FIFO (p)</li>
              <li>De bloque (b)</li>
              <li>De caracter (c)</li>
              <li>Socket (s)</li>
            </ul>
          </section>
          <section>
            <h2>Enlaces duros</h2>
            <ul style="font-size: smaller;">
              <li>Todo inodo debe tener, como mínimo, una ruta para poder acceder a él.</li>
              <li>Cuando creamos un objeto, se crea una entrada en el <em>directorio</em> que apunta a él.</li>
              <li>Podemos crear más entradas que hagan referencia al mismo inodo en otro punto: un <strong>enlace duro</strong>.
                <ul>
                  <li>Les llamamos así porque generalmente los creamos a partir de otra ruta, dando la apariencia de que estamos creando una liga a esa ruta.
                    <ul>
                      <li>Pero todas las referencias al inodo tienen la misma categoría.</li>
                    </ul>
                  </li>
                  <li>Los enlaces duros solo pueden hacerse dentro del mismo sistema de archivos.</li>
                </ul>
              </li>
            </ul>
          </section>
          <section>
            <h2>Enlaces simbólicos</h2>
            <ul>
              <li>Son archivos que apuntan a una ruta.</li>
              <li>Su contenido es la ruta a la que apuntan.</li>
              <li>Los enlaces simbólicos no están unidos al inodo del objeto al que apuntan.
                <ul>
                  <li>La ruta apuntada puede no existir: tenemos entonces un <em>enlace roto</em>.</li>
                </ul>
              </li>
              <li>Al acceder a una ruta de un enlace simbólico, el sistema resolverá automáticamente la ruta a la que apunta, y proveerá ese inodo.</li>
              <li>A pesar del nombre, no tienen nada qué ver con los enlaces duros.</li>
            </ul>
          </section>
          <section>
            <h2>Enlaces simbólicos en NT</h2>
            <div style="font-size: smaller;">
              <p>NTFS tiene varias características similares implementadas.</p>
              <dl class="lista-natural" style="font-size: smaller;">
                <dt>Enlaces simbólicos</dt><dd>Muy parecidos a su contraparte en Unix.</dd>
                <dt><i>Junction points</i></dt><dd>Una característica para directorios, que solo puede apuntar a rutas absolutas locales.</dd>
                <dt>Accesos directos</dt><dd>Archivos regulares, que contienen información sobre un objeto. Son interpretados por el shell.</dd>
                <dt>Objetos de shell</dt><dd>Entradas especiales entendidas por el shell para enlazar directorios, definidas en el Registro de Windows.</dd>
              </dl>
              <p>De todos estos, los accesos directos son los más utilizados.</p>
            </div>
          </section>
          <section>
            <h2>Accesos directos</h2>
            <ul>
              <li>Son archivos que contienen información sobre el archivo al que apuntan.</li>
              <li>Tienen la extensión <code>.lnk</code> cuando apuntan a recursos locales, o <code>.url</code>, para recursos remotos.</li>
              <li>No son implementadas por el sistema: el Explorador de Windows ejecuta la acción sobre el archivo apuntado cuando se intenta acceder al acceso directo.</li>
            </ul>
          </section>
        </section>
        <section>
          <section>
            <h2>Montaje</h2>
            <ul style="font-size: smaller;">
              <li>¿Pueden existir dos sistemas de archivos al mismo tiempo?
                <ul class="fragment">
                  <li>El sistema solo puede trabajar con un sistema de archivos a la vez, dado que solo hay un árbol de directorios.</li>
                </ul>
              </li>
              <li class="fragment">Para poder trabajar con otros sistemas de archivos, debemos <em>montarlos</em> en el sistema de archivos principal.
                <ul>
                  <li>Esto es <strong>hacer que un sistema de archivos esté accesible desde una ubicación determinada</strong>.</li>
                  <li>A esa ubicación le llamamos <strong>punto de montaje</strong>: un directorio dentro del sistema de archivos principal.</li>
                  <li>Si el punto de montaje ya tenía archivos, éstos estarán ocultos.</li>
                </ul>
              </li>
            </ul>
          </section>
          <section>
            <h2>fstab</h2>
            <p>En el archivo <code>/etc/fstab</code> están listados los sistemas de archivos que el SO ya conoce, y sabe donde montar.</p>
            <img src="images/montaje.png" alt="Sistemas de archivos montados" />
          </section>
          <section>
            <h2>Proceso de montaje</h2>
            <ul>
              <li>Podemos montar cualquier sistema de archivos, siempre y cuando haya algún <em>controlador</em> para dicho sistema.</li>
              <li>Unix tiene dos utilidades para administrar montajes:
                <ul>
                  <li><strong>mount</strong> ⇒ monta sistemas de archivos en un directorio.</li>
                  <li><strong>unmount</strong> ⇒ revierte esa operación.</li>
                </ul>
              </li>
            </ul>
            <pre class="bash" style="font-size: smaller;"><code>mount -t ext4 -o ro,loop imagen /punto-montaje/</code></pre>
          </section>
        </section>
        <section>
          <section>
            <h2>Permisos Unix</h2>
          </section>
          <section>
            <h2>Propiedad</h2>
            <ul>
              <li>Todos los archivos y directorios en un sistema Unix pertenecen a un usuario y grupo en específico.</li>
              <li>Solo el propietario de un archivo y el usuario root pueden cambiar estos permisos.</li>
              <li>Esto es parte del estándar POSIX.
              </li>
            </ul>
            <img src="images/permisos.png" alt="Permisos" />
          </section>
          <section>
            <h2>chown y chgrp</h2>
            <ul>
              <li>Estos dos comandos nos permitirán modificar el usuario y grupo dueño de un archivo: <em>chown</em> y <em>chgrp</em>.
                <pre class="bash"><code>[comando] [-RL | -h] usuario|grupo objetivo</code></pre>
              </li>
              <li>Parámetros específicos:
                <ul>
                  <li><code>-R</code> aplica recursivamente.</li>
                  <li><code>-L</code> atraviesa enlaces simbólicos a directorios.</li>
                  <li><code>-h</code> aplica la acción sobre el enlace simbólico, en vez de sobre el objeto apuntado.</li>
                </ul>
              </li>
            </ul>
          </section>
          <section>
            <h2>Permisos</h2>
            <p style="font-size: smaller;">Todos los archivos y directorios en un sistema Unix tienen 3 tipos de permisos básicos, que indican qué usuarios pueden operar con ellos, y cómo:</p>
            <table style="font-size: smaller;">
              <tr>
                <th scope="col">Permiso</th>
                <th scope="col">Archivos</th>
                <th scope="col">Directorios</th>
              </tr>
              <tr>
                <th scope="row">Lectura (r)</td>
                <td>Leer el archivo</td>
                <td>Listar archivos dentro del directorio (ls)</td>
              </tr>
              <tr>
                <th scope="row">Escritura (w)</td>
                <td>Escribir sobre el archivo</td>
                <td>Modificar entradas del directorio: crear, renombrar y borrar archivos</td>
              </tr>
              <tr>
                <th scope="row">Ejecución (x)</td>
                <td>Ejecutar el archivo</td>
                <td>Moverte al directorio (cd), o buscar dentro del directorio</td>
              </tr>
            </table>
          </section>
          <section>
            <h2>setuid y setgid</h2>
            <p>Existe forma de otorgar ciertos permisos elevados a un usuario común <strong>cuando ejecuta un programa</strong>.</p>
            <ul>
              <li><b>Sobre ejecutables</b>: otorga al usuario los permisos del dueño del ejecutable (setuid), o del grupo (setgid).</li>
              <li><b>Sobre directorios</b>: setuid es ignorado, setgid obliga a que todos los archivos dentro del directorio tengan el mismo grupo dueño.</li>
            </ul>
          </section>
          <section>
            <h2>sticky</h2>
            <ul>
              <li>Dos permisos diferentes, en realidad:
                <ul>
                  <li><strong>Sobre ejecutables</strong>: hace que un ejecutable se quede residente en memoria principal.</li>
                  <li><strong>Sobre directorios</strong>: evita que un usuario modifique detalles sobre archivos que no posee.</li>
                </ul>
              </li>
              <li>El uso sobre ejecutables ya no se implementa en casi ningún sistema Unix.
                <ul><li>Sí en UnixWare y HP-UX.</li></ul>
              </li>
            </ul>
          </section>
          <section>
            <h2>chmod</h2>
            <ul>
              <li>El comando para modificar permisos en archivos es <em>chmod</em>.
                <pre><code>chmod [permisos] [objetivo]</code></pre>
              </li>
              <li>Parámetros específicos:
                <ul>
                  <li><code>-R</code> aplica recursivamente.</li>
                  <li><code>-L</code> atraviesa enlaces simbólicos a directorios.</li>
                  <li>chmod no cambia permisos de enlaces simbólicos, puesto que éstos nunca se ocupan en el sistema.</li>
                </ul>
              </li>
            </ul>
          </section>
        </section>
        <section>
          <section>
            <h2>Notación de permisos</h2>
          </section>
          <section>
            <h2>Notación numérica o absoluta</h2>
            <p>Consiste en un número octal de tres dígitos, un dígito por agente.</p>
            <img src="images/numerica.png" alt="Notación numérica" />
          </section>
          <section>
            <h2>Operaciones con chmod (I)</h2>
            <ul>
              <li>Establecer permisos base con chmod es sencillo, ejemplo:
                <pre><code>chmod 644 archivo.txt</code></pre>
              </li>
              <li>Establecer los bits setuid, setgid y sticky se hace anteponiendo un dígito octal que establece los tres permisos en el orden descrito:
                <pre><code>chmod 1644 archivo.txt</code></pre>
              </li>
            </ul>
          </section>
          <section>
            <h2>Notación simbólica</h2>
            <div class="r-stack">
              <div>
                <p>Consiste en una cadena de letras, donde cada letra especifica un permiso. Además, incluye otros datos.</p>
                <img src="images/simbolica.png" alt="notación simbólica" />
              </div>
              <ul class="fragment" style="font-size: smaller;">
                <li>En la posición para indicar el permiso ejecutable, pueden haber otros caracteres, dependiendo de si los bits especiales están activos:
                  <ul>
                    <li>Si setuid o setgid están activos: s o S, dependiendo de si el archivo es o no ejecutable.</li>
                    <li>Si sticky está activo, t o T, dependiendo de si el archivo es o no ejecutable.</li>
                  </ul>
                </li>
                <li>Pueden aparecer estos símbolos al final:
                  <ul>
                    <li>+ si existen permisos adicionales.</li>
                    <li>- si existe un contexto SELinux.</li>
                    <li>@ si existen atributos de archivos extendidos.</li>
                  </ul>
                </li>
              </ul>
            </div>
          </section>
          <section>
            <h2>Operaciones con chmod (II)</h2>
            <p>En vez de simplemente establecer todos los permisos, podemos añadir o quitar solo algunos a voluntad:</p>
            <ul>
              <li>Añadir permisos:
                <pre class="inline-code bash"><code data-trim="">chmod tipos+permisos</code></pre>
              </li>
              <li>Quitar permisos:
                <pre class="inline-code bash"><code data-trim="">chmod tipos-permisos</code></pre>
              </li>
              <li>Establecer permisos:
                <pre class="inline-code bash"><code data-trim="">chmod tipos=permisos</code></pre>
              </li>
            </ul>
          </section>
        </section>
        <section>
          <section>
            <h2>Sistemas de archivos virtuales</h2>
            <ul>
              <li>Hasta ahora hemos hablado de sistemas de archivos que funcionan con datos en un <em>soporte físico</em>: son los <strong>sistemas de archivos de disco</strong>.</li>
              <li>Pero la analogía del archivero tiene más usos, y puede ser usada para exponer datos que no necesariamente están en un soporte.
                <ul>
                  <li><strong>Sistemas de archivos de red</strong>: sshfs, nfs, ftpfs, ...</li>
                  <li><strong>Sistemas de archivos de propósito especial</strong>: tmpfs, swap, lufs, devfs, sysfs, ...</li>
                </ul>
              </li>
            </ul>
          </section>
          <section>
            <h2>Ejemplos</h2>
            <ul>
              <li>Las rutas de una URL tienen forma de ruta de archivo, pero no necesariamente tienen que ser archivos, por eso siempre hablamos de <i>recursos</i>.</li>
              <li><strong>Filosofía Unix:</strong> todo es un archivo.</li>
              <li><strong>FUSE:</strong> crea tu propio sistema de archivos.</li>
            </ul>
          </section>
        </section>
        <!--TERCER TEMA-->
        <section>
          <section id="tercertema">
            <h2>Tema 3:<br />Sistemas de paquetes</h2>
          </section>
          <section>
            <h2>Introducción</h2>
            <ul>
              <li>El sistema operativo no realiza funciones útiles para el usuario per se.
                <ul>
                  <li>Se limita a gestionar los recursos del sistema…
                  </li>
                  <li>…y a proveer interfaces comunes para éstos.</li>
                </ul>
              </li>
              <li>Necesita de sistemas para realizar tareas específicas para el usuario: <em>aplicaciones</em>.
                <ul>
                  <li>Necesita de sistemas para administrar los sistemas anteriores, o realizar tareas de apoyo: <em>utilidades</em>.</li>
                </ul>
              </li>
            </ul>
          </section>
          <section>
            <figure>
              <img class="r-stretch" src="images/GRUB.png" alt="GRUB" />
              <figcaption>GRUB: una especie de SO con solo una interfaz de línea de comandos.</figcaption>
            </figure>
          </section>
        </section>
        <section>
          <section>
            <h2>¿Sistemas o programas?</h2>
            <ul style="font-size: smaller;">
              <li>Nótese que no hablamos de programas de aplicación, o programas de utilidades, sino de sistemas de aplicación y sistemas de utilidades.
              </li>
              <li>Hay qué notar la diferencia entre conceptos, será importante:
                <ul>
                  <li>Un programa es un conjunto de instrucciones: un ejecutable… o bibliotecas con código ejecutable.</li>
                  <li>Un sistema puede ser un programa (generalmente lo es), pero no tiene por qué serlo.
                    <ul>
                      <li>Ejemplos: packs de íconos, documentación.</li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
          </section>
          <section>
            <h2>Sistema</h2>
            <ul>
              <li>Un sistema se organiza generalmente en varios archivos, con distintas funcionalidades.
                <ul>
                  <li>Como mínimo, uno, aunque eso es algo raro.</li>
                  <li>Ejecutables, bibliotecas, recursos multimedia de distintas clases.
                  </li>
                </ul>
              </li>
              <li>En cada sistema operativo existen formas distintas de organizar los archivos de los sistemas instalados.
              <ul>
                <li>En los sistemas Unix, comúnmente se sigue el estándar <strong>Filesystem Hierarchy Standard</strong>.</li>
              </ul>
              </li>
            </ul>
          </section>
          <section>
            <h2>Filesystem Hierarchy Standard</h2>
            <div class="cont-img">
              <ul style="font-size: smaller;">
                <li>Estándar que especifica la estructura de los directorios en el sistema de archivos de un sistema Unix.</li>
                <li>La mayor parte de las distribuciones Linux lo siguen, con cambios menores.</li>
              </ul>
              <img style="width: 400px;" src="https://upload.wikimedia.org/wikipedia/commons/d/d6/Ubuntu_Filesystem_Hierarchy.png" alt="Estructura de un sistema FHS" />
            </div>
          </section>
          <section>
            <h2>Directorios FHS (I)</h2>
            <dl style="font-size: smaller">
              <dt>/</dt><dd>directorio raíz y <strong>jerarquía primaria</strong>: adminnistrado por el sistema.</dd>
              <dt>/bin</dt><dd>ejecutables que deben estar disponibles en modo monousuario.</dd>
              <dt>/boot</dt><dd>archivos para el arranque.</dd>
              <dt>/dev</dt><dd>inodos de dispositivo.</dd>
              <dt>/etc</dt><dd>archivos de configuración.</dd>
              <dt>/home</dt><dd>directorios personales de usuarios.</dd>
            </dl>
          </section>
          <section>
            <h2>Directorios FHS (II)</h2>
            <dl style="font-size: smaller">
              <dt>/lib</dt><dd>bibliotecas para los ejecutables en /bin.</dd>
              <dt>/lib&lt;qual&gt;</dt><dd>bibliotecas específicas para los ejecutables en /bin, en sistemas que soportan más de un formato ejecutable.</dd>
              <dt>/media</dt><dd>puntos de montaje para dispositivos removibles.</dd>
              <dt>/mnt</dt><dd>puntos de montaje.</dd>
              <dt>/opt</dt><dd>paquetes de aplicación variados.</dd>
              <dt>/proc</dt><dd>sistemas de archivos virtuales que exponen información sobre procesos y el kernel.</dd>
            </dl>
          </section>
          <section>
            <h2>Directorios FHS (III)</h2>
            <dl style="font-size: smaller">
              <dt>/root</dt><dd>directorio personal del superusuario.</dd>
              <dt>/run</dt><dd>información sobre la sesión existente del sistema.</dd>
              <dt>/sbin</dt><dd>ejecutables para la administración del sistema.</dd>
              <dt>/srv</dt><dd>datos que el sistema puede servir.</dd>
              <dt>/sys</dt><dd>información sobre dispositivos y sus controladores.</dd>
              <dt>/tmp</dt><dd>archivos temporales.</dd>
            </dl>
          </section>
          <section>
            <h2>Directorios FHS (IV)</h2>
            <dl style="font-size: smaller">
              <dt>/usr</dt><dd><strong>jerarquía secundaria</strong>: directorios para software de aplicación y de utilidad administrados por el administrador de paquetes.</dd>
              <dt>/usr/bin</dt><dd>ejecutables del software de aplicación y de utilidad.</dd>
              <dt>/usr/include</dt><dd>archivos de cabecera de C y C++.</dd>
              <dt>/usr/lib</dt><dd>análogo de /lib para ejecutables en /usr/bin.</dd>
              <dt>/usr/libexec</dt><dd>ejecutables que no están pensados para ejecutarse por sí mismos.</dd>
            </dl>
          </section>
          <section>
            <h2>Directorios FHS (V)</h2>
            <dl style="font-size: smaller">
              <dt>/usr/lib&lt;qual&gt;</dt><dd>análogo de /lib&lt;qual&gt; para ejecutables en /usr/bin.</dd>
              <dt>/usr/local</dt><dd><strong>jerarquía terciaria</strong>: directorios para software de aplicación y de utilidad administrados por el administrador de sistema.</dd>
              <dt>/usr/sbin</dt><dd>análogo de /sbin.</dd>
              <dt>/usr/share</dt><dd>archivos de datos de aplicación.</dd>
              <dt>/usr/src</dt><dd>código fuente.</dd>
            </dl>
          </section>
          <section>
            <h2>Directorios FHS (VI)</h2>
            <dl style="font-size: smaller">
              <dt>/var</dt><dd>directorio para datos variables de una aplicación.</dd>
              <dt>/var/cache</dt><dd>archivos de caché.</dd>
              <dt>/var/lib</dt><dd>archivos de estados de programas.</dd>
              <dt>/var/lock</dt><dd>archivos de bloqueo, representan recursos en uso.</dd>
              <dt>/var/log</dt><dd>archivos de logs.</dd>
              <dt>/var/mail</dt><dd>correos electrónicos del usuario en espera de ser leídos.</dd>
            </dl>
          </section>
          <section>
            <h2>Directorios FHS (VII)</h2>
            <dl style="font-size: smaller;">
              <dt>/var/spool</dt><dd>cola para tareas a procesar.</dd>
              <dt>/var/tmp</dt><dd>archivos temporales que no deben borrarse entre reinicios.</dd>
            </dl>
          </section>
        </section>
        <section>
          <section>
            <h2>Configuracion de usuario</h2>
            <ul>
              <li>Los directorios especificados por FHS en general solo son modificables por el sistema.
                <ul>
                  <li>Un no-superusuario no puede personalizar su propia configuración en estos directorios.
                  </li>
                </ul>
              </li>
              <li>Tradicionalmente, cada aplicación usaba un directorio oculto en el directorio de usuario.
                <ul>
                  <li>Esto llenaba muchas veces el directorio de usuario, y no había un orden dentro de cada directorio de aplicación.</li>
                </ul>
              </li>
            </ul>
          </section>
          <section>
            <h2>XDG Base Directory Specification</h2>
            <ul style="font-size: smaller;">
              <li>El proyecto Freedesktop.org propuso un estándar para especificar directorios para datos de un sistema específicos para un usuario:
                <ul>
                  <li><code>XDG_DATA_HOME</code> ($HOME/.local/share): /usr/share</li>
                  <li><code>XDG_CONFIG_HOME</code> ($HOME/.config): /etc</li>
                  <li><code>XDG_STATE_HOME</code> ($HOME/.local/state): /var/lib</li>
                  <li><code>XDG_CACHE_HOME</code> ($HOME/.cache): /var/cache</li>
                  <li><code>XDG_RUNTIME_DIR</code></li>
                </ul>
              </li>
            </ul>
          </section>
          <section>
            <ul>
              <li>Y también para especificar directorios para los datos personales del usuario:
                <ul>
                  <li><code>XDG_DESKTOP_DIR</code> ($HOME/Desktop)</li>
                  <li><code>XDG_DOCUMENTS_DIR</code> ($HOME/Documents)</li>
                  <li><code>XDG_DOWNLOAD_DIR</code> ($HOME/Downloads)</li>
                  <li><code>XDG_MUSIC_DIR</code> ($HOME/Music)</li>
                  <li><code>XDG_PICTURES_DIR</code> ($HOME/Pictures)</li>
                  <li><code>XDG_PUBLICSHARE_DIR</code> ($HOME/Public)</li>
                  <li><code>XDG_TEMPLATES_DIR</code> ($HOME/Templates)</li>
                  <li><code>XDG_VIDEOS_DIR</code> ($HOME/Videos)</li>
                </ul>
              </li>
            </ul>
          </section>
        </section>
        <section>
          <section>
            <h2>Paquete</h2>
            <ul style="font-size: smaller;">
              <li>Para instalar un sistema en el SO, los archivos que lo componen deben ubicarse según las convenciones descritas arriba.</li>
              <li>Para ser distribuidos, todos estos archivos se recopilan en <strong>paquetes</strong> con un <em>formato determinado</em>.</li>
              <li>Además de los archivos propios del proyecto, un paquete suele contener metadatos sobre el sistema, e instrucciones para realizar las operaciones sobre el paquete.</li>
              <li>Los paquetes no se manejan manualmente, normalmente son usados por un <strong>administrador de paquetes</strong>.
              </li>
            </ul>
          </section>
          <section>
            <h2>Administrador de paquetes</h2>
            <ul>
              <li>Sistema que automatiza la administración <strong>de paquetes de forma consistente</strong>.</li>
              <li>¿Qué es administrar un paquete?
                <ul>
                  <li class="fragment">Obtenerlos</li>
                  <li class="fragment">Instalarlos</li>
                  <li class="fragment">Configurarlos</li>
                  <li class="fragment">Actualizarlos</li>
                  <li class="fragment">Eliminarlos</li>
                  <li class="fragment">Gestionar dependencias entre ellos</li>
                </ul>
              </li>
            </ul>
          </section>
          <section>
            <h2>Diferencias con un instalador</h2>
            <table style="font-size: smaller;">
              <col style="width: 50%" />
              <col style="width: 50%" />
              <tr>
                <th scope="col">Instalador</th>
                <th scope="col">ADP</th>
              </tr>
              <tr>
                <td>Individual para cada programa</td>
                <td>Gestiona muchos programas (y sus relaciones)
                </td>
              </tr>
              <tr>
                <td>Creado por el programador del programa</td>
                <td>Provienen todos de la misma fuente</td>
              </tr>
              <tr>
                <td>Cada programador usa el formato que desee</td>
                <td>Establece un formato común</td>
              </tr>
              <tr>
                <td>Organiza el contenido de los paquetes a como desee el proveedor</td>
                <td>Organiza el contenido en ubicaciones específicas</td>
              </tr>
            </table>
          </section>
          <section>
            <h2>Diferencias con una tienda de aplicaciones</h2>
            <div class="r-stack">
              <ul style="font-size: smaller;" class="fragment">
                <li>Las tiendas de aplicaciones pueden considerarse una clase especial de administradores de paquetes.
                  <ul>
                    <li>Pero limitadas a instalar software de aplicación.</li>
                  </ul>
                </li>
                <li>Están diseñadas generalmente con un propósito <i>comercial</i>.
                  <ul>
                    <li>Permitir pagos por la aplicación.</li>
                    <li>Ofrecer paquetes <em>monolíticos</em>, sin dependencias.</li>
                    <li>Simplificar la experiencia, asemejándola a una tienda real.</li>
                  </ul>
                </li>
              </ul>
              <ul class="fragment">
                <li>Los administradores de paquetes generalmente trabajan con código.
                  <ul>
                    <li>Existen revisiones manuales de código antes de generar los binarios y publicarse.</li>
                    <li>En las tiendas de aplicaciones no, porque generalmente el código no está disponible.</li>
                  </ul>
                </li>
              </ul>
            </div>
          </section>
        </section>
        <section>
          <section>
            <h2>Administradores y formatos</h2>
            <ul>
              <li>En general, un administrador de paquetes trabaja con un solo formato, pero no siempre es así.</li>
              <li>Caso ejemplo: los paquetes .deb pueden diferir entre familias y subfamilias de Debian.
                <ul>
                  <li>Pueden cambiar el modo de organización de archivos.</li>
                  <li>Pueden incluir versiones diferentes de dependencias.</li>
                  <li>Aunque en todas las distros se use apt.</li>
                </ul>
              </li>
            </ul>
          </section>
          <section>
            <h2>Administradores y formatos más usados</h2>
            <div class="cont-img">
              <ul style="font-size: smaller;">
                <li>apk (Alpine Linux)</li>
                <li>AppImage</li>
                <li>APPX (Windows 8+)</li>
                <li>Deb/dpkg (familia Debian)</li>
                <li>Flatpak</li>
                <li>Portage/ebuild (Gentoo)</li>
                <li>Ports (BSD*)</li>
                <li>RPM/DNF (Red Hat, Fedora)</li>
                <li>RPM/Yum (Red Hat antes, familia SUSE)</li>
                <li>Snap</li>
              </ul>
              <img style="width: 200px;" src="https://upload.wikimedia.org/wikipedia/commons/e/e7/Application-x-deb.svg" alt="Paquet Debian" />
            </div>
          </section>
          <section>
            <h2>Repositorios</h2>
            <ul style="font-size: smaller;">
              <li>Los administradores de paquetes obtienen los paquetes de un conjunto de fuentes centralizadas.
                <ul>
                  <li>Generalmente provistas por la distribución/sistema operativo.</li>
                </ul>
              </li>
              <li>A estas fuentes las llamamos <strong>repositorios</strong>.</li>
              <li>Los repositorios pueden estar en Internet (HTTP, FTP), o pueden ser locales (CDs, disquetes)</li>
              <li>En algunos sistemas, una fuente puede proveer varios <em>canales</em>.
                <ul>
                  <li>En el sistema de Debian, a estos canales se les llama <em>componentes</em>.</li>
                </ul>
              </li>
              <li>En este curso, nos enfocaremos en el sistema provisto por Debian y todas sus distribuciones derivadas: <strong>dpkg</strong>.
              </li>
            </ul>
          </section>
          <section>
            <h2>dpkg (I)</h2>
            <ul>
              <li>La base del sistema de administración de paquetes de Debian.
              </li>
              <li>Se encarga de la instalación, eliminación y consulta de información del formato nativo: .deb.</li>
              <li>En general, dpkg no se utiliza directamente, puesto que es una herramienta de bajo nivel.
                <ul>
                  <li>En su lugar, se usan frontends que gestionan cosas como la descarga, o las dependencias, y usan dpkg por debajo.</li>
                </ul>
              </li>
            </ul>
          </section>
          <section>
            <h2>dpkg (II)</h2>
            <p>Los comandos principales de dpkg son:</p>
            <ul>
              <li>Instalar un paquete:
                <pre class="inline-code bash"><code data-trim="">dpkg -i archivo</code></pre>
              </li>
              <li>Listar paquetes instalados:
                <pre class="inline-code bash"><code data-trim="">dpkg -l [patrón]</code></pre>
              </li>
              <li>Desinstalar un paquete:
                <pre class="inline-code bash"><code data-trim="">dpkg -r paquete</code></pre>
              </li>
            </ul>
          </section>
          <section>
            <h2>deb</h2>
            <ul>
              <li>El formato usado por dpkg para empaquetar.</li>
              <li>Consiste en un archivador ar que contiene tres archivos en este orden:
                <ul>
                  <li><i>debian-binary</i>, que contiene la versión a usar del formato.</li>
                  <li><i>control.tar</i>, que contiene los scripts de configuración y metadatos.</li>
                  <li><i>data.tar</i>, que contiene los archivos instalables.</li>
                </ul>
              </li>
            </ul>
          </section>
          <section>
            <h2>apt (I)</h2>
            <ul style="font-size: smaller;">
              <li>La interfaz de usuario predeterminada para dpkg.</li>
              <li>apt tiene funciones que complementan y potencian a dpkg.</li>
              <li>apt puede descargar los paquetes desde los repositorios:
                <ul><li>La lista de repositorios está en <code>/etc/apt/sources.list</code>.</li></ul>
              </li>
              <li>apt administra las dependencias durante las operaciones:
                <ul>
                  <li>Resuelve la instalación de dependencias faltantes.</li>
                  <li>Impide la instalación si hay conflictos entre paquetes.</li>
                </ul>
              </li>
            </ul>
          </section>
          <section>
            <h2>apt (II)</h2>
            <ul style="font-size: smaller;">
              <li>apt contiene varios subcomandos para administrar los paquetes:
                <dl class="lista-natural">
                  <dt><code>apt update</code></dt><dd>Actualiza el listado de paquetes desde los repositorios.</dd>
                  <dt><code>apt upgrade</code></dt><dd>Actualiza los paquetes instalados.</dd>
                  <dt><code>apt full-upgrade</code></dt><dd>Como <code>apt upgrade</code>, pero incluso cuando el proceso elimina paquetes.</dd>
                  <dt><code>apt install</code></dt><dd>Instala un paquete, y sus dependencias.</dd>
                  <dt><code>apt remove</code></dt><dd>Desinstala un paquete del sistema.</dd>
                  <dt><code>apt search</code></dt><dd>Busca paquetes por una expresión regular.</dd>
                  <dt><code>apt show</code></dt><dd>Muestra detalles sobre un paquete del repositorio.</dd>
                </dl>
              </li>
            </ul>
          </section>
          <section>
            <h2>Componentes en Debian</h2>
            <ul>
              <li>Los repositorios de Debian se separan en tres componentes:
                <ul>
                  <li><i>main</i>: paquetes con software libre.</li>
                  <li><i>contrib</i>: paquetes con software libre, pero que dependen de paquetes no disponibles en main.</li>
                  <li><i>non-free</i>: paquetes con software privativo.</li>
                </ul>
              </li>
              <li>Desde Debian 12, existe un cuarto componente, que contiene solo los controladores que solían estar en <i>non-free</i>: <i>non-free-firmware</i>.</li>
            </ul>
          </section>
          <section>
            <h2>Componentes en Ubuntu</h2>
            <p>A diferencia de Debian, Ubuntu es mantenido por una empresa (Canonical), entonces también se separan los paquetes mantenidos por la empresa de los que no:</p>
            <table>
              <tr>
                <th scope="col">Soporte</th>
                <th scope="col">Software libre</th>
                <th scope="col">Software privativo</th>
              </tr>
              <tr>
                <th scope="row">Por Canonical</th>
                <td>main</td>
                <td>restricted</td>
              </tr>
              <tr>
                <th scope="row">Comunitario</th>
                <td>universe</td>
                <td>multiverse</td>
              </tr>
            </table>
          </section>
          <section>
            <h2>apt pinning</h2>
            <ul>
              <li>En una instalación, pueden existir varios repositorios que hagan referencia al mismo paquete (aunque varíen en versiones).</li>
              <li>Podemos indicarle a apt qué opción debe elegir:
                <ul>
                  <li>Para evitar incompatibilidades.</li>
                  <li>Para escoger especialmente una versión.</li>
                </ul>
              </li>
              <li>El archivo que registra estas preferencias se encuentra en <code>/etc/apt/preferences</code>.</li>
            </ul>
          </section>
          <section>
            <h2>Metapaquetes</h2>
            <ul>
              <li>Hay paquetes que conviene instalar juntos, aunque no sean dependencias directas:
                <ul>
                  <li>Porque agrupan paquetes que comúnmente irían juntos, aunque puedan instalarse por separado: <i>ubuntu-desktop</i>, <i>build-essential</i>.
                  </li>
                  <li>Porque agrupan "ediciones" de componentes: <i>texlive-full</i>, <i>texlive-basic</i>.</li>
                </ul>
              </li>
              <li>Para eso, existen los <strong>metapaquetes</strong>: paquetes que declaran dependencias hacia otros paquetes, provocando su instalación cuando el metapaquete sea instalado.</li>
            </ul>
          </section>
          <section>
            <h2>Paquete virtual</h2>
            <ul style="font-size: smaller;">
              <li>Hay paquetes que dependen de un sistema concreto.
                <ul>
                  <li>De ese sistema concreto, pueden existir varias versiones muy similares, que pueden ser utilizadas indistintamente.
                  </li>
                  <li>Pero un paquete no puede declarar dependencias de tipo "escoge uno de varios" directamente.</li>
                </ul>
              </li>
              <li>La solución son los <strong>paquetes virtuales</strong>:
                <ul>
                  <li>Paquetes que no tienen contenido, sino que representan un nombre genérico para un grupo de paquetes.</li>
                  <li>Se dice entonces que los paquetes del grupo pueden "proveer" el paquete virtual.</li>
                  <li>Si un paquete de dicho grupo está instalado, la dependencia hacia el paquete virtual se considera resuelta.</li>
                </ul>
              </li>
            </ul>
          </section>
          <section>
            <h2>Frontends para apt (I)</h2>
            <ul>
              <li>apt viene a simplificar mucho el uso de dpkg, sin embargo, es una utilidad de consola.
                <ul>
                  <li>Mucha gente sigue encontrando difícil el manejo de la consola.</li>
                </ul>
              </li>
              <li>Existen muchos frontends que usan apt por debajo.
                <ul><li>Tal como apt usa dpkg por debajo.</li></ul>
              </li>
            </ul>
          </section>
          <section>
            <h2>Frontends para apt (II)</h2>
            <div class="cont-img">
              <ul>
                <li>Synaptic</li>
                <li>Ubuntu Software Center</li>
                <li>aptitude</li>
                <li>Apper</li>
                <li>PackageKit</li>
                <li>Gnome Software</li>
                <li>KDE Discover</li>
              </ul>
              <img style="width: 400px;" src="https://upload.wikimedia.org/wikipedia/commons/8/87/Synaptic_Package_Manager.png" alt="Synaptic" />
            </div>
          </section>
        </section>
        <!--CUARTO TEMA-->
        <section>
          <section id="cuartotema">
            <h2>Tema 4:<br />Shells</h2>
          </section>
          <section>
            <h2>Shell</h2>
            <div class="cont-img">
              <p>Una <strong>shell</strong> o <strong>intérprete</strong> de línea de comandos, es un programa que permite enviar comandos al sistema, normalmente, tanto de <em>forma interactiva</em> como <em>por lotes</em>.</p>
              <img style="width: 400px;" src="images/shell.png" alt="shell" />
            </div>
          </section>
          <section>
            <h2>Terminales</h2>
            <p>La primera forma de interactuar con una shell es mediante una <strong>terminal</strong>: interfaz de texto que permite introducir comandos y mostrar el resultado.</p>
            <ul class="comparador">
              <li>Terminales de hardware
                <ul>
                  <li>Teletipos</li>
                  <li>VDUs</li>
                </ul>
              </li>
              <li>Terminales de software
                <ul>
                  <li>Terminales de texto</li>
                  <li>Emuladores de terminal</li>
                </ul>
              </li>
            </ul>
          </section>
          <section>
            <h2>Teletipo</h2>
            <div class="cont-img">
              <p>Las terminales actuales basan su funcionamiento en la forma en la que trabajan los <em>teletipos</em>: dispositivos para enviar mensajes.</p>
              <img src="images/teletipos.png" alt="teletipos" />
            </div>
          </section>
          <section>
            <h2>Teletype Model 33</h2>
            <div class="cont-img" style="font-size: smaller;">
              <ul style="font-size: smaller">
                <li>Diseñado en 1963 por Teletype Corp.</li>
                <li>Bajo precio: fue muy popular entre las minicomputadoras.</li>
                <li>Fue de las primeras en usar (y popularizar) ASCII.</li>
                <li>Solo permitía mayúsculas, lo que influyó en la sintaxis de muchos lenguajes: BASIC, por ejemplo.</li>
                <li>Tomlinson usó el símbolo @ para las direcciones de correo por que estaba disponible en este teletipo.</li>
              </ul>
              <img src="images/tele33.png" alt="Teletype Model 33" />
            </div>
          </section>
          <section>
            <h2>Terminal de texto</h2>
            <ul style="font-size: smaller;">
              <li>También llamada <em>consola</em>, es el componente del sistema que nos permite interactuar con una shell.</li>
              <li>Prácticamente las terminales soportan caracteres comodín, tuberías, sintaxis HERE, substitución de comandos, variables, y estructuras de control para iteraciones y condicionales.</li>
              <li>Dado a que es un software, el sistema nos provee de varias terminales virtuales, accesibles desde <code>/dev/tty<var>x</var></code>.</li>
              <li>Y desde C-M-&lt;fx&gt; (Ctrl-Alt-&lt;Fx&gt;)</li>
            </ul>
          </section>
          <section>
            <h2>Emulador de terminal</h2>
            <p>En entornos gráficos, también podemos mostrar una terminal de texto dentro de una ventana gráfica. El programa que permite esto es el <strong>emulador de terminal</strong>.</p>
          </section>
          <section>
            <h2>Emuladores más populares</h2>
            <ul>
              <li>Gnome Terminal</li>
              <li>kitty</li>
              <li>Konsole</li>
              <li>rxvt</li>
              <li>Windows Console</li>
              <li>Windows Terminal</li>
              <li>xterm y term</li>
            </ul>
          </section>
          <section>
            <h2>Tipos de shells</h2>
            <table style="font-size: smaller;">
              <tr>
                <th scope="col">Basadas en Bourne-shell</th>
                <th scope="col">Basadas en C-shell</th>
              </tr>
              <tr>
                <td>
                  <p>Creada en 1979 en los Bell Labs. Es la familia más popular hoy en día. Varios detalles, como el uso de $, fueron propuestos por éste.</p>
                  <ul>
                    <li>Alquimist shell (ash y dash)</li>
                    <li>Bourne-again shell (bash)</li>
                    <li>Korn shell (ksh)</li>
                    <li>Z shell (zsh)</li>
                    <li>Friendly-interactive shell (fish)</li>
                  </ul>
                </td>
                <td>
                  <p>Creada en la Universidad de Berkeley, toma su sintaxis del lenguaje C.</p>
                  <p>La shell más utilizada es tcsh.</p>
                </td>
              </tr>
            </table>
          </section>
        </section>
        <!--QUINTO TEMA-->
        <section>
          <section id="quintotema">
            <h2>Tema 5:<br />Comandos de terminal</h2>
          </section>
          <section>
            <p>Programas o utilidades que se ejecutan en linea de comandos.</p>
          </section>
          <section>
            <h2>Rutas</h2>
            <ul>
              <li>pwd - print working directory</li>
              <li>cd - change current directory</li>
              <ul>
                <li>/ - directorio base</li>
                <li>./ - desde el directorio actual</li>
                <li>~ - directorio home del usuario</li>
              </ul>
            </ul>
          </section>
          <section>
            <h2>Archivos</h2>
            <ul>
              <li>ls - list</li>
              <li>cat - view files content</li>
              <li>cp - copy</li>
              <li>mkdir - make new directory</li>
              <li>rmdir - remove directory</li>
              <li>chmod - change files permission</li>
              <li>mv - move files</li>
            </ul>
          </section>
          <section>
            <h2>Busqueda</h2>
            <ul>
              <li>locate - search files</li>
              <li>grep - regex</li>
              <li>find - search</li>
            </ul>
          </section>
          <section>
            <h2>Usuario</h2>
            <ul>
              <li>sudo - superuser</li>
              <li>whoami - show user</li>
              <li>su - change user</li>
            </ul>
          </section>
          <section>
            <h2>Multiples comandos</h2>
            <ul>
              <li>| - pasa el output de un comando al siguiente</li>
              <li>; - sirve para ejecutar comandos de forma secuencial</li>
              <li>& - ejecuta comandos de forma simultanea</li>
              <li>&& - condicional</li>
              <ul><li>com1 && com2 - ejecutar com2 solo si com1 se ejecuta</li></ul>
            </ul>
          </section>
          <section>
            <h2>Pentesting</h2>
            <ul>
              <li>ping - comprobar conexion a una direccion</li>
              <li>id - muestra informacion del usuario</li>
              <li>env - ver variables de entorno</li>
              <li>ifconfig - informacion de la red</li>
            </ul>
          </section>
        </section>
        <!--BASH-->
        <section>
          <section id="sextotema">
            <h2>Tema 6:<br />Bash</h2>
          </section>
          <section>
            <h2>Bash</h2>
            <div class="cont-img">
              <ul style="font-size: smaller;">
                <li>Bash es el intérprete de comandos del proyecto GNU.</li>
                <li>Creado por Brian Fox en 1989.</li>
                <li>Es la shell más popular en los sistemas Linux.</li>
                <li>Bash cumple todas las características descritas por POSIX, pero incluye muchas extensiones.</li>
                <li><a href="https://devhints.io/bash">Cheatsheet de la sintaxis</a>.</li>
              </ul>
              <img style="width: 400px;" src="images/bash.png" alt="bash" />
            </div>
          </section>
        </section>
      </div>
    </div>
    <script src="assets/reveal.js"></script>
    <script src="assets/highlight/highlight.js"></script>
    <script>//<![CDATA[
Reveal.initialize({
  hash: true,
  plugins: [ RevealHighlight ]
});//]]>
    </script>
  </body>
</html>
